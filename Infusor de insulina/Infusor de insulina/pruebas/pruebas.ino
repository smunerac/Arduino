// LIBRERIAS REQUERIDAS#include <U8g2lib.h>  // U8g2 Library for Oled https://github.com/olikraus/u8g2#include "Time.h" #include "Stepper.h" #include <Wire.h>#include <SoftwareSerial.h>//DEFINICIONES BASICAS int loop_pass=1;  // Variable used to display text or the bitmap// U8g2 Library Full Frame Buffer mode used in this tutorialU8G2_SSD1327_MIDAS_128X128_F_4W_HW_SPI u8g2(U8G2_R0, /* cs=*/ 7, /* dc=*/ 9, /* reset=*/ 8);    //DIN=51,CLK=52#define STEPS 20          //Definimos el número de pasos que requiere el motor paso a paso para un giro.SoftwareSerial blue(10,11);       // (RX, TX) en Arduino Stepper stepper(STEPS, /*Marron*/ 28, /*Negro*/29,/*Blanco*/ 30, /*Rojo*/31); //Stepper nombre motor (número de pasos por vuelta, pins de control)//DEFINICION DE PINES Y CONSTANTES UTILIZADAS//int pwm1=0;     //Velocidad del motorint comando;const int pulsador_1 = 22; // Entrada digital para el pulsadorconst int pulsador_2 = 24; // Entrada digital para el pulsadorconst int pulsador_3 = 15; // Entrada digital para el pulsador  const int pulsador_4 = 17; // Entrada digital para el pulsador  const int pulsador_5 = 18; // Entrada digital para el pulsador final de carrera inicialconst int pulsador_6 = 19; // Entrada digital para el pulsador final de carrera finalconst int tiempoAntirrebote = 10; // tiempo en ms para evitar el rebote//Para el funcionamiento de pulsadores con su correccion por antirreboteint cuenta = 0;int estadoBoton_1=0;int estadoBotonAnterior_1=0;int estadoBoton_2=0;int estadoBotonAnterior_2=0; int estadoBoton_3=0;int estadoBotonAnterior_3=0;int estadoBoton_4=0;int estadoBotonAnterior_4=0; int estadoBoton_5=0;int estadoBotonAnterior_5=0;int estadoBoton_6=0;int estadoBotonAnterior_6=0; // Para el calculo del tiempo de ejecucionunsigned long tiempo1;unsigned long tiempo2;unsigned long tiempo_de_ejecucion;unsigned long milesimas;long vel=2500L;             //Definimos la velocidad del motor paso a paso [RPM]int resolucionZ=20;         //[20 Pasos >> 0.1 UI]float bolus_UI=1.5;float basal_UI=0;float bolus_pasos=(-(bolus_UI*200));        //[Pasos a inyectar por el motor]float basal_pasos=-((basal_UI*200));         //(-0.001/Rel_pasos_insulina); //(3/Rel_pasos_insulina);      //[UI-U100]//Relacion de reduccion de la caja (2091425/4212=496.539648623) aprox 500 Rev eje del motor segun fabricantefloat Rel_Red=(2091425/4212);   //Motor chino tipo U//Negativo inyecta//Positivo retrocede//Para el Menuint menuitem = 1;int page = 1; //POR ORDENAR Y DISMINUIR///////////////////////////////////////////////////////////////////////// Para el funcionamiento y ejecucion del dispositivolong pas=(2200L);   //Definimos el numero de pasos a ejecutar//long oe=(-((bolus_UI*Rel_pasos_insulina))),L;long pasos=(2000L);   //Definimos el numero de pasos a ejecutarlong w=(4212/2091425);long varaux5=(pasos);  //*w*5);long contador=pas;  //Variable para guardar la cuenta de pulsaciones// Ponemos nombre al motor, el número de pasos y los pines de controlint direccion;  //Variable para indicar la direccón////////////////////////////////////////////////////////////////////////////////////////////int a=243.6;void setup() {Serial.begin(19200);        //Velocidad de transmicion con el monitor serialblue.begin(9600);           //Velocidad de transmicion con el modulo BluetoothpinMode(pulsador_1, INPUT); // PIN digital del pulsador como entradapinMode(pulsador_2, INPUT); // PIN digital del pulsador como entradapinMode(pulsador_3, INPUT); // PIN digital del pulsador como entradapinMode(pulsador_4, INPUT); // PIN digital del pulsador como entradapinMode(pulsador_5, INPUT); // PIN digital del final de carrera como entradapinMode(pulsador_6, INPUT); // PIN digital del final de carrera como entrada//Pines usados para alimentacion y control de componentespinMode(13, OUTPUT);pinMode(20, OUTPUT);pinMode(47, OUTPUT);//Pantalla Oled 1.5u8g2.begin();                 //  Start U8g2 libraryu8g2.setContrast(200);        //  Brightness setting from 0 to 255u8g2.clearBuffer();  //Borrar pantalla//u8g2.setFont(u8g2_font_gdr25r);u8g2 . setFont (u8g2_font_fub11_tr);  // Elija la fuente a usaru8g2 . drawStr ( 0 , 20 , "Texto de prueba" );  //  establece la posición y el texto para mostrarenum {BufSize=9};//If a is short use a smaller number, eg 5 or 6 char buf[BufSize];snprintf (buf, BufSize, "%d", a);u8g2.drawStr(33, 50, buf);u8g2.sendBuffer();   // Update Oled display//u8g2.clearBuffer();}  void loop(){//drawMenu();    //Para control de componentesdigitalWrite(13,HIGH);        //Modulo BluetoothdigitalWrite(20,HIGH);        //PantalladigitalWrite(47,HIGH);        //Pulsadores//LECTURA DE PULSADORESestadoBoton_1 = digitalRead(pulsador_1);estadoBoton_2 = digitalRead(pulsador_2); estadoBoton_3 = digitalRead(pulsador_3);estadoBoton_4 = digitalRead(pulsador_4);estadoBoton_5 = digitalRead(pulsador_5);estadoBoton_6 = digitalRead(pulsador_6);//leer_botones();//CONTROL DE VARIABLESif (bolus_UI<0.1){  bolus_UI=0.1; }if (basal_UI<0.1){  basal_UI=0.1; } // Verificamos la disponibilidad del bluethott  if (blue.available() > 0) {    // Leemos el dato.    int comando = blue.read();      switch (comando) {      case 'A':           //Izquierda    u8g2.clearBuffer();  //Borrar pantalla      u8g2 . setFont (u8g2_font_fub11_tr);  // Elija la fuente a usar      u8g2 . drawStr ( 0 , 20 , "primero" );  //  establece la posición y el texto para mostrar      u8g2.sendBuffer();   // Update Oled display      delay(500);         stepper.step(1000);       u8g2.clearBuffer();  //Borrar pantalla        Serial.println("A");   //        inyectar_bolus();        break;      case 'B':           //Arriba    u8g2.clearBuffer();  //Borrar pantalla      u8g2 . setFont (u8g2_font_fub11_tr);  // Elija la fuente a usar      u8g2 . drawStr ( 0 , 20 , "segundo" );  //  establece la posición y el texto para mostrar      u8g2.sendBuffer();   // Update Oled display      delay(500);         stepper.step(1000);      u8g2.clearBuffer();  //Borrar pantalla        Serial.println("B");  //        inyectar_basal();        break;      case 'C':           //Derecha    u8g2.clearBuffer();  //Borrar pantalla      u8g2 . setFont (u8g2_font_fub11_tr);  // Elija la fuente a usar      u8g2 . drawStr ( 0 , 20 , "tercero" );  //  establece la posición y el texto para mostrar      u8g2.sendBuffer();   // Update Oled display      delay(500);         stepper.step(1000);      u8g2.clearBuffer();  //Borrar pantalla        Serial.println("C");  //        adelante();        break;      case 'D':           //Abajo    u8g2.clearBuffer();  //Borrar pantalla      u8g2 . setFont (u8g2_font_fub11_tr);  // Elija la fuente a usar      u8g2 . drawStr ( 0 , 20 , "cuarto" );  //  establece la posición y el texto para mostrar      u8g2.sendBuffer();   // Update Oled display      delay(500);         stepper.step(1000);      if (basal_UI<0.1){      basal_UI=0.1; }      u8g2.clearBuffer();  //Borrar pantalla        Serial.println("D");  //        atras();        break;      case 'E':           //Select        Serial.println("E"); //        apagar();        break;      case 'F':           //Start        Serial.println("F"); //        regresar();        break;      case 'G':           //Cuadro "Izquierda"        Serial.println("G");                break;      case 'H':           //Triangulo "Arriba"        Serial.println("H");        break;      case 'I':          //Cruz "Derecha"        Serial.println("I");           break;      case 'J':         //Circulo "Abajo"        Serial.println("J");        break;      default:         // if nothing matches, do nothing        break;    }  } else{delay(120);         }}  